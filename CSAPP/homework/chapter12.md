- 12.1
```
因为文件表中文件被删除需要引用值为0才行
```

- 12.2
```
因为描述符在子进程执行完后就会被自动关闭
```

- 12.3
```
什么都不会发生，因为EOF并不代表准备好可以读了

XXX
只要当调用read会返回，就表明准备好可以读了
```

- 12.4
```
因为每次select返回会改变pool.ready_set
```

- 12.5
```
因为一个进程中的线程是共享打开的文件的，不论多少个线程使用描述符，其引用始终为1，所以可以在所有线程用完之后关闭
```

- 12.6

A:
|是|是|是|
|---|---|---|
|否|是|是|
|是|否|否|
|是|是|是|
|否|是|否|
|否|否|是|

B: `ptr, cnt, msgs.m`是共享的

- 12.7

|0|-|0|
|---|---|---|
|-|-|0|
|-|0|0|
|-|1|0|
|-|1|1|
|1|-|1|
|1|-|1|
|1|-|1|
|-|1|1|

不会

- 12.8
```
A: 安全
B: 不安全
C: 安全
```

- 12.9
```
XXX
A: 是
B: 否
C: 否
// 不是很能理解，条件不清楚
```

- 12.10
```
在一个写者对占用锁之后，有一个读者与若干写者等候锁，之后每次写者释放锁之后，都被另一个写者占用锁
```

- 12.13
```
因为可能会在对等线程还未获取值的时候主线程已经释放内存了
```

- 12.14
```
A: 在主线程定义一个长度为N的整数数组，将想要传递的值放在对应的元素并传递给对等线程
B: 当N比较大时会占用很多内存，而不是像使用堆一样能够及时释放
```